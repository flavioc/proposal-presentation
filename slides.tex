\documentclass{beamer}

\usepackage[english]{babel}
\usepackage{beamerthemeBoadilla}
%\usepackage{beamerthemeCambridgeUS}
%\usepackage{beamerthemeRochester}
%\usepackage{beamerthemeSzeged}
%\usepackage{beamerthemeMontpellier}
%\usepackage{beamerthemedefault}
\usepackage{url}
\usepackage{verbatim}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage{fancyvrb}
\RecustomVerbatimEnvironment{verbatim}{Verbatim}{}

\def\Tiny{\fontsize{6pt}{6pt}\selectfont}

\title{Linear Logic and Coordination for Parallel Programming}
\author[Flávio Cruz]{Flávio Cruz {\small \texttt{<fmfernan@cs.cmu.edu>}}\\
\scriptsize{\textbf{Committee}:\\
Umut Acar (CMU)\\
Luis Barbosa (University of Minho) \\
Seth Goldstein (CMU)\\
Carlos Guestrin (University of Washington) \\
Frank Pfenning (CMU)\\
Ricardo Rocha (University of Porto)}}

\institute[CMU/UP]{Carnegie Mellon University \\ Pittsburgh, PA 15213, USA \and
CRACS \& INESC TEC, Faculty of Sciences, University Of Porto\\
Rua do Campo Alegre, 1021/1055, 4169-007 Porto, Portugal}
\date{\today}

\let\oldalert\alert
\renewcommand{\alert}[2][]{%
  \if\relax\detokenize{#1}\relax% http://tex.stackexchange.com/q/53068/5764
    \oldalert{#2}% Default overlay
  \else
    \oldalert<#1>{#2}% Specific overlay
  \fi}

\begin{document}

\frame{\titlepage}

\AtBeginSection[] { \begin{frame}<beamer>
\frametitle{Plan} \tableofcontents[currentsection]
\end{frame}}

\section{Motivation}

\frame
{
  \frametitle{Motivation}
}

\section{Linear Meld}

\subsection{Features}

\begin{frame}[fragile]
   \frametitle{Predicates}
   
\end{frame}

\begin{frame}[fragile]
   \frametitle{Rules}
   
\end{frame}


\subsection{Bipartiteness Checking}

\begin{frame}[fragile]
  \frametitle{Bipartiteness Checking}
  \begin{columns}[t]
     \column{.45\textwidth}
     \begin{block}{Program}
       \begin{verbatim}[fontsize=\tiny,commandchars=\\\{\},frame=single]
\alert[1]{type route edge(node, node).}
\alert[1]{type linear mark(node, int).}
\alert[1]{type linear uncolored(node).}
\alert[1]{type linear colored(node, int).}
\alert[1]{type linear fail(node).}

\alert[2]{fun next(int X) : int =}
   \alert[2]{if X <> 1 then 1 else 2 end.}

\alert[3,7]{mark(@1, 1).}
\alert[3]{!edge(@1, @2). !edge(@1, @3).}
\alert[3]{!edge(@2, @4).}
\alert[3]{!edge(@3, @4).}

\alert[4,8,9,10,11]{mark(A, P), uncolored(A)}
   \alert[4,8,9,10,11]{-o \{B | !edge(A, B) | mark(B, next(P))\},}
      \alert[4,8,9,10,11]{colored(A, P).}

\alert[5,12]{mark(A, P), colored(A, P)}
   \alert[5,12]{-o colored(A, P).}
\alert[6]{mark(A, P1), colored(A, P2), P1 <> P2}
   \alert[6]{-o fail(A).}
\alert[6]{mark(A, P), fail(A)}
   \alert[6]{-o fail(A).}
       \end{verbatim}
     \end{block}
      \column{.5\textwidth}
      \begin{block}{\only<1>{Predicates}\only<2>{Functions}\only<3>{Axiom}\only<4>{First rule}\only<5>{Second rule}\only<6>{Third and fourth rule}\only<7-12>{Execution}}
         \centering
         {\scriptsize
         \only<1>{\begin{itemize}
                \item The first argument of every predicate must be typed as \texttt{node}.
                \item Predicates specified as \texttt{route} inform the compiler about the graph data structure.
                \item Predicates specified as \texttt{linear} turns facts of the predicate into linear facts, which can be asserted or retracted.
                \item Predicates not specified as \texttt{linear} are persistent.
                \item Nodes are either \texttt{colored/2} or \texttt{uncolored/1}.
             \end{itemize}}
         \only<2>{\begin{itemize}
               \item LM allows the declaration of recursive functions using a small functional language.
            \end{itemize}}
         \only<3>{\begin{itemize}
                \item Axioms are rules without bodies that are added to the database as soon as the program starts.
                \item Node literals are written as \texttt{@X}, where \texttt{X} is the node number.
             \end{itemize}}
         \only<4>{\begin{itemize}
               \item If a node is scheduled to be \texttt{mark/1}'ed and is \texttt{uncolored/1}, then we can assign the color \texttt{P} to the node by deriving \texttt{colored(A,P)}.
               \item We use a comprehension to mark the neighbor nodes \\
               \texttt{\{B|!edge(A,B)|mark(B,next(P))\}}:
               \begin{itemize}
                  \item {\tiny For every \texttt{!edge(A, B)} in the database we derive a \texttt{mark(B,next(P))}.}
                  \item {\tiny With \texttt{next(P)} we attempt to color the neighbor node with the opposite color.}
               \end{itemize}
         \end{itemize}}
         \only<5>{\begin{itemize}
            \item If a node is to be marked with color \texttt{P} and has color \texttt{P}, then we keep it that way.
         \end{itemize}}
         \only<6>{\begin{itemize}
            \item However, if the colors are different then we derive \texttt{fail/1}.
            \item ... same if the coloring process has already failed.
         \end{itemize}}
         \only<7-12>{
         \begin{figure}[ht]
            \includegraphics<7>[height=4.5cm]{bipartiteness1.pdf}
            \includegraphics<8>[height=4.5cm]{bipartiteness2.pdf}
            \includegraphics<9>[height=4.5cm]{bipartiteness3.pdf}
            \includegraphics<10>[height=4.5cm]{bipartiteness4.pdf}
            \includegraphics<11>[height=4.5cm]{bipartiteness5.pdf}
            \includegraphics<12>[height=4.5cm]{bipartiteness6.pdf}
         \end{figure}
         }
      }
      \end{block}
  \end{columns}
\end{frame}

\subsection{Quick-Sort}

\begin{frame}[fragile]
  \frametitle{Quick-Sort}
  \begin{columns}[t]
       \column{.45\textwidth}
       \begin{block}{Program}
         \begin{verbatim}[fontsize=\tiny,frame=single,commandchars=\\\{\}]
\alert[1]{down(@0, tosort).}

\alert[2]{down(A, [])}
   \alert[2]{-o up(A, []).}
\alert[2]{down(A, [X])}
   \alert[2]{-o up(A, [X]).}
\alert[2]{down(A, [X, Y]),}
\alert[2]{X < Y}
   \alert[2]{-o up(A, [X, Y]).}
\alert[2]{down(A, [X, Y]),}
\alert[2]{X >= Y}
   \alert[2]{-o up(A, [Y, X]).}
\alert[3]{down(A, [X | L])}
   \alert[3]{-o buildpivot(A, L, X, [], []).}
         \end{verbatim}
      \end{block}
      \column{.5\textwidth}
      \begin{block}{Explanation}
         {\scriptsize
         \begin{itemize}
            \only<1>{\item The quick-sort program starts with a single node and dynamically builds the graph of nodes}
            \only<1>{\item A node receives an unsorted list in the second argument of \texttt{down/2} and must generate an \texttt{up/2} fact after sorting the list}
            \only<2>{\item In the base cases, the list can be immediately sorted}
            \only<3>{\item In the recursive case, we split the list...}
         \end{itemize}
         }
      \end{block}
   \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Quick-Sort}
  \begin{columns}[t]
       \column{.5\textwidth}
       \begin{block}{Program}
         \begin{verbatim}[fontsize=\tiny,frame=single,commandchars=\\\{\}]
\alert[2]{buildpivot(A, [], X, Smaller, Greater)}
   \alert[2]{-o exists B, C. (back(B, A), down(B, Smaller),}
            \alert[2]{back(C, A), down(C, Greater),}
            \alert[2]{waitpivot(A, B, C, X)).}

\alert[1]{buildpivot(A, [Y | L], X, Smaller, Greater),}
\alert[1]{Y <= X}
   \alert[1]{-o buildpivot(A, L, X, [Y | Smaller], Greater).}
\alert[1]{buildpivot(A, [Y | L], X, Smaller, Greater),}
\alert[1]{Y > X}
   \alert[1]{-o buildpivot(A, L, X, Smaller, [Y | Greater]).}

\alert[3]{waitpivot(A, NodeSmaller, NodeGreater, Pivot),}
\alert[3]{sorted(A, NodeSmaller, Smaller),}
\alert[3]{sorted(A, NodeGreater, Greater)}
   \alert[3]{-o append(A, Smaller, [Pivot | Greater]).}
   
\alert[3]{up(A, L), back(A, B) -o sorted(B, A, L).}
         \end{verbatim}
      \end{block}
      \column{.45\textwidth}
      \begin{block}{Explanation}
         {\scriptsize
         \begin{itemize}
            \only<1>{\item \texttt{buildpivot/4} will split the list: elements less or equal than \texttt{X} in the fourth argument and elements greater than \texttt{X} in the fifth argument}
            \only<2>{\item Once the list is split, we create nodes \texttt{B} and \texttt{C} that will sort the two sub-lists
            \item \texttt{waitpivot} is then used to wait for the sorted lists from \texttt{B} and \texttt{C}}
            \only<3>{\item Nodes \texttt{B} and \texttt{C} send a \texttt{sorted/3} fact to \texttt{A}
            \item Results are then appended and sent recursively to the root node}
         \end{itemize}
         }
      \end{block}
   \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Quick-Sort}
  \begin{block}{Example Execution}
     \begin{figure}
        \includegraphics<1>[height=4.5cm]{quicksort1.pdf}
        \includegraphics<2>[height=4.5cm]{quicksort2.pdf}
        \includegraphics<3>[height=4.5cm]{quicksort3.pdf}
        \includegraphics<4>[height=4.5cm]{quicksort4.pdf}
        \includegraphics<5>[height=4.5cm]{quicksort5.pdf}
     \end{figure}
  \end{block}
\end{frame}

\section{Coordination}

\subsection{Example Programs}

\section{Proof Theory}

\section{Current Implementation}

\section{Experimental Results}

\section{Roadmap}

\end{document}
